# Код

## Общие стандарты

Во многих языках есть принятый стиль кода, который стоит придерживаться. Некоторые языки явно утверждают его.

Например, питон - стандарт PEP8. Однако не всегда есть какой-то единый стандарт. Хорошой отправной точкой является [стайлгайд от Гугла](https://google.github.io/styleguide/)

Также есть некоторые общие конвенции и пожелания:

### Магические значения

В коде не должно быть магических значений, чисел, строк.
Константы, которые никогда не меняются с изменением кода, должны быть вынесены и именоваться в соответствии со стайлгайдом

Часто есть значения, которые удобно менять пользователю. Их стоит выносить в конфиг

В зависимости от программы, секретные данные бывает лучше выносить в переменные окружения, например, токены

### Имена сущностей

Имена сущностей должны быть осмысленные и содержательные. Имя класса должно отражать его функционал.

Это помогает делать правильную классовую структуру. Часто, если у вас большой и несвязный класс, вроде `Utils` или `Manager`, то стоит пересмотреть классовую структуру

### Отступы

Все отступы должны быть консистентны: 1 TAB = 4 spaces. Также хорошо стоит использовать форматтеры (см далее)

### ООП

Весь функционал должен быть описан в классах. Это необходимо, чтобы объединять данные вместе с функциями над ними.

С таким кодом обычно легче работать. Это является основной идеей ООП.

### Архитектура

Старайтесь выстроить **архитектуру кода**, разделить ответственность на **несколько** классов.
Не стоит писать [God Object](https://en.wikipedia.org/wiki/God_object), который выполняет чрезмерно много функций

Вы можете использовать композицию и абстракцию, чтобы разбить практически любой класс.
Зачастую (но не всегда), если у вас более 400 строк в одном файле, значит, что есть простор для рефакторинга

### Интерфейсы

Интерфейсы и KISS. Где возможно, используйте интерфейсы, чтобы обобщить поведение нескольких классов.
Это сильно упростит поддержку кода. Это очень важный момент, которым часто пренебрегают новички


Однако, не стоит переусложнять архитектуру, если только 1 класс реализует какой-то интерфейс и
не планируется добавлять новых в разумные рамки времени, то интерфейс не нужен.

Зачастую тяжело придумать правильный интерфейс, не зная нескольких классов, которые его реализуют

### Наследование

Будьте аккуратны с наследованием. Наследование имеет узкую зону применения.
Часто будет лучше использовать композицию + абстракцию в лице интерфейсов

### Вложенность

Старайтесь держать небольшой уровень вложенности (меньше 4 табов). Это достигается с помощью early return, разбиения функции на несколько

Важное видео на тему: https://www.youtube.com/watch?v=CFRhGnuXG-4

### Логические блоки

Старайтесь делить тело функции на логические блоки

При возможности объединяйте объявление переменных в отдельные логические блоки.

Желательно:
```c
int n;

int x_a, x_b, x_c;
int y_a, y_b, y_c;

int square;
```

Менее желательно:
```c
int n;
int x_a, x_b, x_c;
int y_a, y_b, y_c;
int square;
```

Совсем не желательно:
```c
// всё смешалось - кони, люди
int n, int x, int price, max_len, i, j, count;
double weight, result, dt, mass, time;
```

Разделяйте логически связанные блоки кода отступами.

Правильно:
```c
for (i = 1; i < N; i++) {
	scanf("%d", &x[i]); 		// первый блок

	if (x[i] > x_max) { 		// второй блок
		x_max = x[i];
	} else if (x[i] < x_min) {
		x_min = x[i];
	}

  x_sum += x[i]; 			// третий блок
}
```

Правильно (и приветствуется):
```c
	for (i = 1; i < N; i++) {
		# объявили 'x' и сразу считали
		int x;
		scanf("%d", &x);

		sum += x;
		...
```

Неправильно:
```c
	// тело цикла записано одним большим куском
	for (i = 1; i < N; i++) {
		scanf("%d", &x[i]);
		if (x[i] > x_max) {
			x_max = x[i];
		} else if (x[i] < x_min) {
			x_min = x[i];
		}
		x_sum += x[i];
	}
```

Еще хуже:
```c
	for (i = 1; i < N; i++) {
		scanf("%d", &x[i]);
		if (x[i] > x_max) x_max = x[i];
		else if (x[i] < x_min) x_min = x[i];
		x_sum += x[i];
	}
```

### SOLID

Придерживайтесь SOLID. Очень важные принципы, гуглите отдельно.

## Линтеры, форматтеры, анализаторы кода

Существует множество линтеров и анализаторов кода для каждого языка.
Стоит использовать линтер и/или форматтер, для того, чтобы держать кодовую базу в однородном одном виде

Например: ESLint, Prettier для JS, rustfmt для Rust

Для некоторых языков, например C++, существуют дополнительные анализаторы кода на содержание некоторых ошибок.
Она тоже полезны, но не сильно распространены за пределами C и C++

